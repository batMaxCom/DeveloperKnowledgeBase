#  Основы Bash:

## Синтаксис и структура скриптов
Базовые правила:
- Первая строка — shebang (`#!/bin/bash`) — указывает путь к интерпретатору
- Комментарии начинаются с `#`
- Каждая команда — на новой строке (или через `;`)
- Скрипт выполняется `сверху вниз`

## Переменные и параметры
```bash
name="Alice"  # Нельзя пробелы вокруг '='
echo $name    # Обращение через $
```
Имена `чувствительны к регистру` (var ≠ Var)

Можно использовать `{}` для точного указания: `${name}script`

Специальные переменные:
- `$0` — имя скрипта
- `$1, $2, ...` — аргументы командной строки
- `$#` — количество аргументов
- `$?` — код возврата последней команды

## Ввод/вывод (echo, read)

### Вывод (echo)
```bash
echo "Текст"           # Простой вывод
echo -e "С\nпереносами"  # Флаг -e для спецсимволов
printf "Формат: %s %d\n" "текст" 42  # Аналог printf из C
```
### Ввод (read)
```bash
read variable          # Чтение в переменную
read -p "Подсказка: " var  # Ввод с подсказкой
read -s -p "Пароль: " pass # Скрытый ввод (для паролей)
```

## Основные операторы

### Арифметические операции
```bash
sum=$((5 + 3))      # $(( ... )) — арифметический контекст
echo $sum           # Выведет 8

# Альтернативы:
let "sum = 5 + 3"   # Команда let
sum=`expr 5 + 3`    # Устаревший способ (не рекомендуется)
```
### Операторы сравнения (для чисел)
```bash
if [ $a -eq $b ]; then  # Равно
if [ $a -ne $b ]; then  # Не равно
if [ $a -gt $b ]; then  # Больше
if [ $a -lt $b ]; then  # Меньше
```

### Строковые операторы
```bash
if [ "$str1" = "$str2" ]; then  # Строки равны
if [ "$str1" != "$str2" ]; then # Не равны
if [ -z "$str" ]; then          # Пустая строка
if [ -n "$str" ]; then          # Не пустая строка
```
### Логические операторы
```bash
if [ $a -eq 5 ] && [ $b -eq 3 ]; then  # И
if [ $a -eq 5 ] || [ $b -eq 3 ]; then  # Или
if ! [ $a -eq 5 ]; then                 # Отрицание
```
### Операторы для файлов
```bash
if [ -f "file.txt" ]; then    # Файл существует
if [ -d "dir" ]; then         # Директория существует
if [ -r "file" ]; then        # Файл доступен для чтения
if [ -w "file" ]; then        # Для записи
if [ -x "file" ]; then        # Для выполнения
```

2. Управляющие конструкции:

## Условия (if/else, case)
### Базовый синтаксис:
```bash
if [ условие ]; then
    # команды если true
elif [ другое условие ]; then
    # команды если true
else
    # команды если все условия false
fi
```

### Пример с числами:
```bash
#!/bin/bash

read -p "Введите число: " num

if [ $num -gt 10 ]; then
    echo "Число больше 10"
elif [ $num -eq 10 ]; then
    echo "Это 10!"
else
    echo "Число меньше 10"
fi
```

### Пример с файлами:
```bash
if [ -f "/path/to/file" ]; then
    echo "Файл существует"
else
    echo "Файл не найден"
fi
```

Важно:
- После if/elif обязательно пробел перед ]
- then на новой строке или после ;
- Закрыть конструкцию fi

## Конструкция case
Альтернатива множественным if для сравнения строк:
```bash
case $переменная in
    шаблон1)
        команды
        ;;
    шаблон2|шаблон3)
        команды
        ;;
    *)
        команды по умолчанию
        ;;
esac
```

Практический пример:
```bash
#!/bin/bash

read -p "Введите действие (start|stop|restart): " action

case $action in
    start)
        echo "Запуск сервиса..."
        ;;
    stop)
        echo "Остановка сервиса..."
        ;;
    restart)
        echo "Перезапуск сервиса..."
        ;;
    *)
        echo "Неизвестная команда"
        exit 1
        ;;
esac
```

## Циклы (for, while, until)
Цикл for:
```bash
for переменная in список; do
    команды
done
```

Пример 1: Перебор значений
```bash
for i in 1 2 3 4 5; do
    echo "Number: $i"
done
```

Пример 2: Перебор файлов
```bash
for file in *.txt; do
    echo "Обработка файла: $file"
done
```

Пример 3: C-подобный синтаксис
```bash
for ((i=0; i<5; i++)); do
    echo "Итерация: $i"
done
```

## Цикл while:
```bash
while [ условие ]; do
    команды
done
```

Пример 1: Счётчик
```bash
counter=0
while [ $counter -lt 5 ]; do
    echo "Counter: $counter"
    ((counter++))
done
```

Пример 2: Чтение файла построчно
```bash
while read line; do
    echo "Строка: $line"
done < file.txt
Цикл until (выполняется пока условие ложно):
bash
until [ условие ]; do
    команды
done
```

Пример:
```bash
count=1
until [ $count -gt 5 ]; do
    echo "Count: $count"
    ((count++))
done
```

## Логические операторы
В условиях:
- `&&` — И (AND)
- `||` — ИЛИ (OR)
- `!` — НЕ (NOT)

Пример 1: Комбинированные условия
```bash
if [ $age -ge 18 ] && [ "$country" = "RU" ]; then
    echo "Доступ разрешён"
fi
```

Пример 2: Проверка ошибок
```bash
mkdir /dir || echo "Не удалось создать директорию" >&2
```

Пример 3: Инверсия условия
```bash
if ! [ -f "/tmp/lock" ]; then
    echo "Файл блокировки отсутствует"
fi
```

## 3. Работа с файлами и строками:

## Чтение/запись файлов
Перезапись файла:

```bash
echo "Первая строка" > file.txt  # Создаст или перезапишет файл
```

Добавление в файл:
```bash
echo "Вторая строка" >> file.txt  # Добавит в конец файла
```

Многострочный ввод (heredoc):
```bash
cat <<EOF > config.cfg # EOF (End-of-File) 
[settings]
user=admin
host=example.com
EOF
```

Использование printf для точного форматирования:

```bash
printf "%-10s %5d\n" "Яблоки" 15 "Апельсины" 8 > fruits.txt
```

Чтение всего файла в переменную:

```bash
content=$(<file.txt)  # Аналог content=$(cat file.txt), но быстрее
```

Построчное чтение (надежный способ):

```bash
while IFS= read -r line || [[ -n "$line" ]]; do
    echo "Прочитано: $line"
done < file.txt
```

Примечание: `IFS=` сохраняет пробелы, -r игнорирует экранирование, || [[ -n "$line" ]] обрабатывает последнюю строку без \n

Чтение в массив:
```bash
mapfile -t lines < file.txt  # Каждая строка - элемент массива lines
echo "Первая строка: ${lines[0]}"
```

## Поиск и замена текста (grep, sed, awk)
Основные примеры:

```bash
grep -in "error" log.txt      # Поиск с номерами строк (i - ignore case)
grep -A2 -B1 "exception" log.txt  # Контекст: 2 строки после и 1 до
grep -v "^#" config.cfg      # Исключить строки, начинающиеся с #
```

Расширенные регулярные выражения:
```bash
grep -E "[0-9]{3}-[0-9]{2}" data.txt  # Поиск шаблона типа 123-45
grep -P "\d{3}-\d{2}" data.txt        # Perl-совместимые regex (если доступно)
```

Основные операции:
```bash
sed 's/old/new/g' file.txt              # Глобальная замена
sed '/^$/d' file.txt                    # Удаление пустых строк
sed -n '10,20p' file.txt                # Вывод строк 10-20
```
Редактирование на месте (разные ОС):
```bash
sed -i.bak 's/foo/bar/' file.txt        # Linux (создаст backup)
sed -i '' 's/foo/bar/' file.txt         # macOS
```

Работа с несколькими командами:
```bash
sed -e 's/foo/bar/' -e '/baz/d' file.txt
```

`Awk` - язык для обработки данных
Базовые шаблоны:
```bash
awk '{print $1}' file.txt               # Первое поле каждой строки
awk -F: '{print $1, $3}' /etc/passwd    # Разделитель ":"
```

Условная обработка:
```bash
awk '$3 > 100 {print $1, $2}' data.txt  # Если 3-е поле > 100
awk 'NR % 2 == 0' file.txt              # Четные строки
```
Статистика:
```bash
awk '{sum+=$1} END{print sum}' data.txt  # Сумма первого столбца
```

## Работа с путями и именами файлов

Безопасное соединение путей:

```bash
dir="/path/to"
file="data.txt"
fullpath="${dir%/}/${file}"  # ${dir%/} убирает trailing slash если есть
```

Разбор путей:

```bash
filename="${fullpath##*/}"     # Только имя файла (data.txt)
extension="${filename##*.}"    # Расширение (txt)
basename="${filename%.*}"      # Имя без расширения (data)
```

Рекурсивная обработка файлов:

```bash
find /path -type f -name "*.log" -exec grep -l "error" {} +
```

Безопаснее чем for с подстановкой, если много файлов

Проверки:

```bash
[[ -e "$file" ]]       # Существует
[[ -f "$file" ]]       # Обычный файл
[[ -d "$dir" ]]        # Директория
[[ -s "$file" ]]       # Не пустой
[[ -r "$file" ]]       # Доступен для чтения
```

4. Функции и параметры:

## Создание функций

Базовый синтаксис:
```bash
function_name() {
    # Тело функции
    commands
}
```

Или альтернативный вариант:
```bash
function function_name {
    # Тело функции
    commands
}

```

Пример простой функции:
```bash
greet() {
    echo "Привет, мир!"
}

# Вызов
greet
```

Особенности:
- Функции должны быть объявлены перед их использованием
- Имена функций чувствительны к регистру
- Можно объявлять функции в любом месте скрипта (но лучше в начале)

## Передача аргументов

Получение параметров:
- `$1, $2, ...` — аргументы (аналогично параметрам скрипта)
- `$0` — имя скрипта (не функции!)
- `$#` — количество аргументов
- `$@` — все аргументы как отдельные строки
- `$*` — все аргументы как одна строка

Пример:
```bash
print_details() {
    echo "Имя: $1"
    echo "Возраст: $2"
}

print_details "Анна" 28
```

Проверка аргументов:
```bash
check_args() {
    if [ $# -lt 2 ]; then
        echo "Ошибка: нужно 2 аргумента" >&2
        return 1
    fi
    # Основная логика
}
```

## Возврат значений

Способ 1: Код возврата (0-255)
```bash
is_even() {
    if [ $(($1 % 2)) -eq 0 ]; then
        return 0  # Успех
    else
        return 1  # Ошибка
    fi
}

is_even 10
echo "Результат: $?"  # $? содержит код возврата
```

Способ 2: Возврат данных через echo
```bash
calculate() {
    local sum=$(( $1 + $2 ))
    echo $sum  # Выводим результат
}

result=$(calculate 5 3)  # Перехватываем вывод
echo "Сумма: $result"
```

Способ 3: Глобальные переменные (не рекомендуется)
```bash
global_result=""

store_result() {
    global_result=$(( $1 * $2 ))
}

store_result 4 5
echo $global_result
```

## Продвинутые техники
1. Локальные переменные
```bash
func() {
    local var="значение"  # Видна только внутри функции
}
```

2. Возврат массивов
```bash
create_array() {
    local arr=("$@")
    echo "${arr[@]}"
}

my_array=($(create_array "один" "два"))
echo "${my_array[1]}"  # выведет "два"
```

3. Рекурсивные функции
```bash
factorial() {
    if [ $1 -le 1 ]; then
        echo 1
    else
        local prev=$(factorial $(( $1 - 1 )))
        echo $(( $1 * prev ))
    fi
}

echo "Факториал 5: $(factorial 5)"
```

5. Продвинутые темы:

Обработка ошибок

Фоновые процессы

Работа с массивами

Регулярные выражения

