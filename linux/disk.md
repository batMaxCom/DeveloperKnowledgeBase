# Управление дисками и разделими (Parted)
`sudo parted` - для входа в интерактивную оболочку
`quit` - для выхода 

Обозначения дисков:
- `/dev/sda` — это имя жесткого диска
- `/dev/sr0` или `/dev/scd0/`  - привода оптических дисков

Первый диск будет иметь имя `sda`.
Каждый следующий обнаруженный диск будет использовать следующую букву.
Например: `/dev/sdb`, `/dev/sdc` и `/dev/sdd`.

Каждый раздел будет именоваться числами по пордяку, если их несколько.
Например: `/dev/sda1`, `/dev/sda2` и `/dev/sda3`.

## Обзор существующих дисков и разделов

`print devices` - показать все доступные диски
`print all` - вывести информацию о всех дисках и всех разделах
`print free` - определить наличие на диске свободного пространства, не занятого ни одним разделом

## Выбор диска для управления
`select /dev/sdb` - выбрать диск
`sudo parted /dev/sda` - вход в интерактивную оболочку конкретного диска

## Создание разделов
Синтаксис создания новых разделов GPT имеет вид:
`mkpart name fs-type start end`

Пример создания новых разделов. В данном случае создается 2 раздела `images` и `audio`.
`mkpart "images" ext4 1MB 2004MB`
`mkpart "audio files" xfs 2005MB 100%`

Где:
- `images/audio` - названия разделов
- `ext4/xfs` - формат файловой системы

Далее указываются начала и конец дискового пространства:
- `1MB 2004MB` - от 1 мегабайта 2004МБ
- `2005MB 100%` - с конца первого раздела да 100% дискового пространства

Если начало или конец окажется `слишком близко` к другому разделу, то `parted сообщит об ошибке`.
Начать `с нуля нельзя`, поскольку `первые 33 сектора зарезервированы` для метки EFI, поэтому первый раздел может начинаться только с сектора с порядковым `номером 34 или выше`.
В параметре `end` можно передать `абсолютное` или `процентное` значение размера.

## Удаление разделов
`rm 1` - удалить раздел `1`

## Восстановление разделов
Если в разделе имелась файловая система и данные, то приступить к восстановлению нужно немедленно. 
В интерактивной оболочке parted выполните команду rescue и укажите начало и конец раздела. Они могут быть приблизительными:
`rescue 2000MB 4010MB`

## Увеличение размера раздела
Проверить свободное дисковое пространство:
`print free`

Пустое дисковое пространство может быть до и после раздела.
Изменить можно только конечную точку раздела, поэтому следующие примеры расширяют раздел 2, добавляя к нему 510 Мбайт свободного места в конце.
Сначала расширим раздел до новой конечной точки:
`resizepart 2 4010MB`

## Уменьшение размера раздела
Размер файловой системы `XFS` нельзя уменьшить, можно только увеличить.
Уменьшить можно `Ext4`, `Btrfs` и FA`T16/32`. `Ext4` и `FAT16/32` должны быть размонтированы перед сжатием. 
`Btrfs` можно сжать не размонтируя, но безопаснее сначала все-таки размонтировать ее.


Требуется удостовериться, что занятое дисковое пространство меньше размера, до которого требуется сжать раздел.
`du -sh /media/duchess/shrinkme` узнать размер директории

`922.6M /media/duchess/shrinkme`

Кроме того, около `40 %` от суммарного объема файлов `следует оставить` для метаданных, не полностью занятых блоков и так на всякий случай, поэтому в данном случае новый размер не должен быть меньше 1,4 Гбайт.

После размонтирования выбранной файловой системы выполните следующие шаги:
- проверьте файловую систему;
- уменьшите размер файловой системы;
- уменьшите размер раздела.

Выполните следующую команду, :
`sudo e2fsck -f /dev/sdc2` - чтобы проверить файловую систему Ext4
`sudo btrfs check /dev/sdc2` - Чтобы проверить Btrfs
`sudo fsck.vfat -v /dev/sdc2` Чтобы проверить FAT16/32

Команды для увеличения размеров файловых систем:
Ext4 `sudo resize2fs /dev/sdc2 2g`
Btrfs `sudo btrfs filesystem resize 2g /dev/sdc2`
FAT16/32 `sudo fatresize -s 2G /dev/sdc2`

В интерактивном режиме `parted`:
`resizepart 1 2000MB` - уменьшить размер раздела, приведя его в соответствие с размером файловой системы

# Создание файловых систем и управление ими

`cat /proc/filesystems` - поддержка каких файловых систем предусмотрена в системе Linux

`nodev` -  это виртуальные файловые системы, которые существуют только в памяти и не подключены к физическим устройствам

## Идентификация существующих файловых систем
`lsblk -o NAME,FSTYPE` - можно получить только имена устройств и названия файловых систем
`lsblk -o NAME,FSTYPE /dev/sdb` - Запросить информацию о конкретном диске
`lsblk -o NAME,FSTYPE /dev/sda1` - о конкретном разделе
`lsblk -o NAME,FSTYPE,LABEL,FSSIZE,FSUSE%,MOUNTPOINT` - показывает все имена устройств, типы и размеры файловых систем, процент заполнения, метки и точки монтирования

Полей вывода достаточно много, том числе: PATH, LABEL, UUID, HOTPLUG, MODEL, SERIAL и SIZE. 
Узнать о них можно через `lsblk --help`

`vfat` — это `Virtual FAT`, драйвер файловой системы ядра для `FAT16` и `FAT32`.
Используйте GParted или parted, чтобы узнать точный тип файловой системы.

## Создание файловой системы Ext4


`df -Th /media/duchess/stuff/` - проверить, куда смонтирована текущая файловая система 

`sudo umount /media/duchess/stuff` - размонтировать файловую систему

`sudo mkfs.ext4 -L 'mylabel' /dev/sdb1` - Создание новой файловой системы Ext4
Где:
- `-L` определяет метку тома. Меткой может быть любая строка длиной до 16 символов (FAT32 ограничивает метку 11 символами).
Метки `не являются обязательными`, но могут пригодиться в некоторых случаях, например, их можно использовать в файле /etc/fstab вместо длинных UUID.
- `-n` выполняет пробный прогон. Добавив его, вы увидите, что произойдет, без фактического создания новой файловой системы.

## Удаление файловых систем

Прежде чем удалить файловую систему, необходимо ее размонтировать.
`lsblk -f` - Чтобы узнать куда она смонтирована
`umount /media/duchess/stuff` - размонтировать файловую систему
`sudo parted /dev/sdb` - войти в интерактивный режим управления диском
`rm 1` - удалить раздел, вместе с файловой системой

## Использование новой файловой системы

Создание точки монтирования после создания файловой систему:

`Ext4, XFS и Btrfs` имеют средства управления доступом.
`FAT16/32` и `exFAT` не имеют средств управления доступом и открыты для всех.

`sudo mkdir -p /mnt/madmax/newfs` - создание точки монтирования
`sudo mount /dev/sdb1 /mnt/madmax/newfs` - смонтировать файловую систему

Назначение прав пользователю на использование файловой системой:
`sudo chown -R madmax:madmax /mnt/madmax/newfs`
`sudo chmod -R 0755 /mnt/madmax/newfs`

## Автоматическое монтирование файловой системы
Для автоматического монтирования при запуске системы необходимо отредактировать файл файл `/etc/fstab`, добавив разделы в формате:

<файловая система> <точка монтирования> <тип> <параметры> <дамп> <порядок проверки>

Где:
`устройство` — UUID или метка файловой системы. Не используйте имена /dev, поскольку они неуникальны и иногда могут изменяться. Выполните команду `lsblk -o UUID, LABEL`, чтобы получить список UUID и меток файловой системы, которые можно использовать в столбце «устройство»;
`точка монтирования` — каталог, созданный вами для монтирования файловой системы;
`тип` — тип файловой системы, например xfs, ext4 или btrfs. Можно использовать и тип auto, чтобы ядро автоматически определяло тип файловой системы;
`параметры` — список параметров монтирования через запятую (поддерживаемые параметры перечислены ниже);
`дамп` — если вы используете команду dump для резервного копирования, то число в этом столбце подскажет команде dump интервал резервного копирования в днях. Число 1 означает каждый день, 2 — каждый второй день,3 — каждый третий день и т. д. Скорее всего, вы не используете dump, поэтому укажите в этом поле 0;
`порядок проверки` — данное число сообщает программе проверки, какую файловую систему проверять в первую очередь при загрузке, если это понадобится. Для корневой файловой системы в этом поле должно быть число 1, для других файловых систем Linux — число 2, а для файловых систем, неродных для Linux, — число 0.

Следующие параметры определяют разрешения:
`defaults` — включает параметры: rw, suid, dev, exec, auto, nouser и async. Значения, определяемые параметром defaults, можно переопределить добавлением дополнительных параметров, например, defaults,user разрешает монтировать и размонтировать файловую систему простым пользователям.
Вы можете добавить сколько угодно параметров или опустить defaults и указать только те параметры, которые вам нужны;
`rw` — для чтения записи;
`ro` — только для чтения;
`suid` — включить поддержку битов setuid и setgid;
`dev` — интерпретировать блочные и символьные устройства;
`exec` — разрешить запуск двоичных файлов;
`auto` — указывает, какие файловые системы должны монтироваться при загрузке;
`nouser` — рядовые пользователи не могут монтировать или размонтировать файловую систему;
`async` — асинхронный ввод/вывод, стандартный параметр для Linux;
`user` — рядовой пользователь может монтировать файловую систему и размонтировать ее, если она была смонтирована им;
`users` — любой пользователь может монтировать и размонтировать файловую систему;
`noauto` — не монтировать автоматически при загрузке;
`noatime` — не обновляйте атрибут файлов «время последнего доступа». В прошлом параметр noatime использовался для повышения производительности. Если у вас современный компьютер, то, вероятно, этот параметр не будет иметь большого значения;
`gid` — ограничить доступ группой (из /etc/group); например, gid=group1.

Используйте команду findmnt для проверки новой конфигурации:
`sudo findmnt --verbose --verify`

## Настройка режима журналирования
Как известно, по умолчанию в Ext4 используется режим журналирования `data=ordered`, в котором журналируются не данные, а только метаданные.

Ниже представлены режимы журналирования в порядке уменьшения безопасности данных:

`data=journal` — обеспечивает максимальную защиту данных. Все данные и метаданные сначала записываются в журнал, а затем в файловую систему.
В случае сбоя этот режим дает наилучшие шансы на восстановление данных. 
Однако он также является самым ресурсоемким, поскольку все изменения записываются дважды;

`data=ordered` — в этом режиме данные не записываются в журнал. 
Данные сначала записываются в файловую систему, а затем метаданные записываются в журнал. 
Метаданные логически сгруппированы по порядку и хранятся в одной транзакции. Когда они записываются на диск, сначала записываютсясвязанные с ними блоки данных;

`data=writeback` — самый быстрый и наименее безопасный режим. Данные сначала записываются в файловую систему, а затем метаданные записываются в журнал. Порядок записи данных не сохраняется. 
Я не думаю, что небольшой прирост производительности стоит дополнительного риска.

`dmesg | grep sdb1` - проверка текущего режима журналирования

`sudo tune2fs -o journal_data /dev/sdb1` - изменение типа журналирования

## Внутренние и внешние журналы
`sudo dumpe2fs -h /dev/sda1 | grep -i uuid` - опросить файловую систему, для определения журнала

Если в ней `отсутствует строка с UUID` журнала, значит используется `внутренний` журнал.
Если присутствует `Journal UUID`, значит внешний.

## Освобождение пространства, занятого зарезервированными блоками, в файловой системе Ext4
По умолчанию резервируется 5 % — это пережиток времен жестких дисков небольшой емкости. Жесткие диски теперь способны вместить так много, что нет необходимости резервировать целых 5 %.

`sudo tune2fs -m 1 /dev/sda1` - уменьшение резерва блоков до 1%
`sudo tune2fs -m .25 /dev/sda1` - указать в долях процента
`sudo tune2fs -r 250000 /dev/sda1` - указать размер в блоках

`sudo dumpe2fs -h /dev/sda1` - получить полную информацию о разделе ext4
`sudo tune2fs -l /dev/sda1 | grep -i 'reserved block'` - проверить зарезервированные блоки
`sudo tune2fs -l /dev/sda1 | grep -i 'block size'` - узнать размер блока
